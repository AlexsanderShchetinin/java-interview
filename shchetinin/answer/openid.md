## OpenID Connect 

Основы OIDC

Если просто, то OIDC — это безопасный механизм, позволяющий приложению связаться со службой идентификации, 
чтобы получить необходимые данные о пользователе и вернуть их обратно в приложение, обеспечив полную защиту данных.

По своей сути, OpenID Connect начинал свой путь как механизм авторизации OAuth "любительского уровня" или, 
если говорить более высокопарно, "механизм, предоставляющей пользователю возможность создать единую учетную запись 
для аутентификации на множестве не связанных друг с другом интернет-ресурсов".

Именно поэтому, в нем есть много схожих деталей с OAuth таких, как: **client_id, client_secret и redirect_uri,**
которые хранятся в системе управления доступами. 
Все они предназначены для того, чтобы обеспечить передачу данных от конкретного человека конкретному приложению.

## процессы OAuth

сначала нужно авторизоваться в системе управления доступами, 
а затем дать права на использование персональных данных с вашей страницы.

такие права называются scopes — области видимости. Для OIDC существует особая область видимости openid, которую необходимо использовать в качестве первого обращения к системе управления доступами.

Сразу после того, как мы разобрались со scopes, возникает следующий резонный вопрос: “Как работать с OpenID?”.

если вы используете приложение JavaScript, где всё и вся может просматриваться любым, 
кто использует инструменты-разработчики браузера, а также отсутствует бэкенд-механизм, 
чтобы скрыть информацию от любопытных глаз пользователей — на помощь придет **Implicit Flow** для OpenID Connect.

Если же вы пользуетесь более традиционными приложениями, где какая-то информация передается на фронтенд 
(и есть вероятность, что кто-то может ее перехватить), но в то же время используется бэкенд, 
чтобы передавать информацию службе управления доступами абсолютно конфиденциально, используйте **Authentication Flow.**

Также существует **Hybrid Flow**, который является сочетанием двух вышеупомянутых методов.

### Implicit Flow
В спецификации OIDC обращается особое внимание, 
что запрашиваемая информация о пользователе должна быть упакована в **JWT (JSON токен)**, зашифрована или подписана. 
Более того, информация об этих шагах (как и когда упакована/зашифрована/подписана) 
должна быть включена в набор данных, отправляемых обратно.

В конечном счете, требования к Implicit flow таковы: 
он должен использовать схему открытого / закрытого ключа для шифрования или подписи информации о пользователе, 
а также содержать в полной конфиденциальности **client_secret**.

Таким образом приложение может удостовериться в том, что данные о пользователе (именуемые claims в OIDC) 
поступают из надежного источника (что это не переадресация на поддельный URL) и частная информация 
(к примеру, client_secret) полностью защищена от посторонних глаз.

В принципе, любой может "украсть" открытый ключ и идентификатор пользователя, но это не имеет абсолютно никакого значения, 
поскольку только система управления доступами владеет необходимой информацией 
(URL-адресом переадресации и секретным ключом), чтобы использовать ее по назначению.

### Authentication Flow
Данный флоу разработан, чтобы функционировать как стандартный three-legged OAuth. 
В итоге обычный токен доступа OAuth секретным образом возвращается в веб-приложение через вызовы, 
сделанные на серверной части.

В таком флоу вместо передачи данных о пользователе, служба управления доступами отправляет 
специальный одноразовый пароль, который можно обменять на токен доступа OAuth через бэкенд сервис. 
Такой обмен должен включать client_id и client_secret в дополнение к коду, также, как и в стандартном флоу OAuth.

Затем токен доступа OAuth должен быть использован веб-сервисом для подтверждения подлинности, 
а также для запроса разного рода информации о пользователе (это определяется запрошенными типами scopes и claims).

Сейчас, в мире, где существуют разнообразные службы управления доступами, 
такие claims обычно предварительно утверждаются администратором, отвечающим за настройку приложения, 
но на любительском уровне (где непосредственно конечный пользователь подтверждает доступ к приложению)
они выступают в виде запросов на разрешение (scopes) во время изначального application flow.

OIDC определяет целый ряд claims, и некоторые из них имеют довольно узкое определение 
(например, только email адрес пользователя), в то время, как другие являются довольно обширными и могут возвращать 
любую запрошенную информацию системе управления доступами (такую, как, например, информация о профиле пользователя).

В дополнение, хочется отметить, что cистемы OIDC также предоставляют refresh-токен 
(если веб-сервису необходим более длительный доступ к информации о пользователе), 
так же, как и персонализированные claims.