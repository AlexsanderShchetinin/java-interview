
## Иерархия коллекций

Рассмотрим из чего состоит ArrayList в Java 21

#### public interface Iterable<T>
Корневой интрефейс, который
имеет метод iterator(), который должен возвращать объект одноименного интерфейса Iterator<E>, который в свою очередь 
имеет метод hasNext() для проверки наличия следующего элемента в коллекции.
Из названия интерфейса Iterable понятно что он итерирует, то есть повторяет одно и тоже действие - перебирает коллекцию!
это один из самых основных интерфейсов на котором далее построены все коллекции!
от этого интерфейса в 21 версии Java библиотеки наследуются аж 469 !!! других классов и интерфейсов 

### public interface Collection<E> extends Iterable<E> 
Следующим интерфейсом на пути к динамическому массиву (ArrayList) является **Collection** - один из наследников Iterable
Данный интерфейс уже имеет множество методов, которые мы привыкли использовать в ArrayList:
+ ```int size()``` - возвращает кол-во элементов коллекции
+ ```boolean isEmpty()``` - если коллекция пустая то должен возвращать true
+ ```boolean contains(Object o)``` - проверяет наличие определенного объекта в коллекции
+ ```toArray()``` - toArray() в различных реализациях с разными сигнатурами метода, может возвращать массив Object, либо массив элементов либого другого типа через дженерики
+ ```boolean add(E e)``` - добавление элемента в коллекцию
+ ```boolean remove(Object o)``` - удаление элемента из коллекции
+ ```void clear()``` - удаляет ВСЕ элементы из коллекции
+ ```default boolean removeIf(Predicate<? super E> filter)``` - удаляет елементы по определенному условию - фильтру. Возможно использовать с функциональным подходом предиката
+ ```boolean removeAll(Collection<?> c)``` - удаляет все элементы из текущей коллекции, которые передаются в параметре метода
+ ```boolean addAll(Collection<? extends E> c)``` - добавляет все элементы из текущей коллекции, которые передаются в параметре метода
+ ```boolean containsAll(Collection<?> c)``` - проверяет, содержатся ли все элементы в коллекции, которые передаются в параметре другой коллекции

**_также с версии Java 1.8 появились методы для параллельного выполнения потоков:_**
+ ```default Spliterator<E> spliterator() { return Spliterators.spliterator(this, 0):}```
+ ```default Stream<E> stream() { return StreamSupport.stream(spliterator(), false);}```
+ ```default Stream<E> parallelStream() { return StreamSupport.stream(spliterator(), true);}```

### public interface SequencedCollection<E> extends Collection<E>
**SequencedCollection** наследует Collection добавляя в нее методы очередности. 
